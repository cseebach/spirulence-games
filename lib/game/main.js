// Generated by CoffeeScript 1.3.3
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ig.module('game.main').requires('impact.game', 'impact.font').defines(function() {
    var BackGround, Borehole, BuildQueue, BuildingButton, DomeGenerator, Factory, Generator, Mine, MyGame, Placeable, QuantomOptoComptroller, ResearchCenter, Supercollider, advRobotics, extremeRobotics, highEnergyPhysics, quantumComputing, secretsOfTheUniverse, theoryOfEverything;
    Placeable = ig.Entity.extend({
      size: {
        x: 16,
        y: 16
      },
      collides: ig.Entity.COLLIDES.PASSIVE,
      mineralsConsumed: 0,
      mineralsProduced: 0,
      energyConsumed: 0,
      energyProduced: 0,
      productionProduced: 0,
      productionCost: 0,
      research: 0,
      placed: false,
      init: function(x, y, settings) {
        return this.parent(x, y, settings);
      },
      canPlace: function() {
        if (this.getMineralsConsumed() > ig.game.mineralsProduced - ig.game.mineralsConsumed) {
          return false;
        }
        if (this.getEnergyConsumed() > ig.game.energyProduced - ig.game.energyConsumed) {
          return false;
        }
        return true;
      },
      place: function() {
        this.placed = true;
        return this.currentAnim.alpha = 1;
      },
      getMineralsConsumed: function() {
        return this.mineralsConsumed;
      },
      getMineralsProduced: function() {
        return this.mineralsProduced;
      },
      getEnergyConsumed: function() {
        return this.energyConsumed;
      },
      getEnergyProduced: function() {
        return this.energyProduced;
      },
      getProductionProduced: function() {
        return this.productionProduced;
      },
      getProductionCost: function() {
        return this.productionCost;
      },
      getResearch: function() {
        return this.research;
      }
    });
    DomeGenerator = Placeable.extend({
      size: {
        x: 16,
        y: 16
      },
      collides: ig.Entity.COLLIDES.PASSIVE,
      animSheet: new ig.AnimationSheet("media/dome_generator.png", 16, 16),
      energyConsumed: 100,
      productionCost: 3000,
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.addAnim("idle", 0.05, [0, 1, 2, 3, 4, 5, 6, 7]);
      },
      place: function() {
        var generators, numGenerators, _ref;
        this.parent();
        generators = ig.game.getEntitiesByType(DomeGenerator);
        numGenerators = generators.length;
        if (_ref = ig.game.placeEntity, __indexOf.call(generators, _ref) >= 0) {
          numGenerators -= 1;
        }
        if (numGenerators >= 4) {
          ig.game.winning = true;
          return ig.game.winCondition = "generators";
        }
      }
    });
    QuantomOptoComptroller = Placeable.extend({
      size: {
        x: 16,
        y: 16
      },
      collides: ig.Entity.COLLIDES.PASSIVE,
      animSheet: new ig.AnimationSheet("media/qo_comptroller.png", 16, 16),
      energyConsumed: 10,
      productionCost: 1000,
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.addAnim("idle", 0.2, [0, 1, 2, 3]);
      },
      getEnergyProduced: function() {
        var energyProduced, generator, generators, _i, _j, _len, _len1, _ref;
        _ref = ig.game.getEntitiesByType(Generator);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          generator = _ref[_i];
          if (generator.placed) {
            generators = generator;
          }
        }
        energyProduced = 0;
        for (_j = 0, _len1 = generators.length; _j < _len1; _j++) {
          generator = generators[_j];
          if (generator.distanceTo(this) < 30) {
            energyProduced += 5;
          }
        }
        return energyProduced;
      }
    });
    Supercollider = Placeable.extend({
      size: {
        x: 16,
        y: 16
      },
      collides: ig.Entity.COLLIDES.PASSIVE,
      animSheet: new ig.AnimationSheet("media/supercollider.png", 16, 16),
      research: 20,
      energyCost: 50,
      productionCost: 2000,
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.addAnim("idle", 0.1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
      },
      getResearch: function() {
        var center, research, researchCenters, _i, _j, _len, _len1, _ref;
        _ref = ig.game.getEntitiesByType(ResearchCenter);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          center = _ref[_i];
          if (center.placed) {
            researchCenters = center;
          }
        }
        research = this.research;
        for (_j = 0, _len1 = researchCenters.length; _j < _len1; _j++) {
          center = researchCenters[_j];
          if (center.distanceTo(this) < 30) {
            research += 5;
          }
        }
        return energyProduced;
      }
    });
    ResearchCenter = Placeable.extend({
      size: {
        x: 16,
        y: 16
      },
      collides: ig.Entity.COLLIDES.PASSIVE,
      animSheet: new ig.AnimationSheet("media/research_center.png", 16, 16),
      energyCost: 10,
      research: 10,
      productionCost: 100,
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.addAnim("idle", 0.1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 4, 3, 2, 1, 0, 0, 0]);
      }
    });
    Borehole = Placeable.extend({
      size: {
        x: 16,
        y: 16
      },
      collides: ig.Entity.COLLIDES.PASSIVE,
      animSheet: new ig.AnimationSheet("media/borehole.png", 16, 16),
      energyCost: 20,
      productionCost: 200,
      mineralsProduced: 20,
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.addAnim("idle", 0.2, [0, 0, 0, 1, 2, 3, 4, 4, 3, 2, 1, 0, 0, 0]);
      },
      getMineralsProduced: function() {
        var mine, mineralsProduced, mines, _i, _j, _len, _len1, _ref;
        _ref = ig.game.getEntitiesByType(Mine);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          mine = _ref[_i];
          if (mine.placed) {
            mines = mine;
          }
        }
        mineralsProduced = this.mineralsProduced;
        for (_j = 0, _len1 = mines.length; _j < _len1; _j++) {
          mine = mines[_j];
          if (mine.distanceTo(this) < 30) {
            mineralsProduced += 5;
          }
        }
        return mineralsProduced;
      }
    });
    Generator = Placeable.extend({
      size: {
        x: 16,
        y: 16
      },
      collides: ig.Entity.COLLIDES.PASSIVE,
      animSheet: new ig.AnimationSheet('media/generator.png', 16, 16),
      productionCost: 40,
      energyProduced: 6,
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.addAnim('idle', 0.1, [0, 1]);
      }
    });
    Mine = Placeable.extend({
      size: {
        x: 16,
        y: 16
      },
      collides: ig.Entity.COLLIDES.PASSIVE,
      animSheet: new ig.AnimationSheet("media/mine.png", 16, 16),
      energyCost: 1,
      mineralsProduced: 3,
      productionCost: 40,
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.addAnim('idle', 0.2, [0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1, 0, 0, 0, 0, 0]);
      }
    });
    Factory = Placeable.extend({
      size: {
        x: 16,
        y: 16
      },
      collides: ig.Entity.COLLIDES.PASSIVE,
      animSheet: new ig.AnimationSheet("media/factory.png", 16, 16),
      energyCost: 6,
      mineralsCost: 6,
      productionProduced: 3,
      productionCost: 100,
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.addAnim('idle', 0.4, [0, 1]);
      }
    });
    BackGround = ig.Entity.extend({
      size: {
        x: 320,
        y: 240
      },
      zIndex: 50,
      animSheet: new ig.AnimationSheet("media/background.png", 320, 240),
      init: function(x, y, settings) {
        this.parent(x, y, settings);
        return this.addAnim('idle', 0.1, [0]);
      }
    });
    BuildingButton = ig.Class.extend({
      buttonBack: new ig.Image("media/button.png"),
      init: function(x, y, buildingClass, enabled) {
        var tempInstance;
        tempInstance = new buildingClass(-100, -100, {});
        this.x = x;
        this.y = y;
        this.size = 16;
        this.buildingClass = buildingClass;
        this.image = tempInstance.animSheet.image;
        this.enabled = enabled != null ? enabled : true;
        this.hovered = false;
        this.queue = [];
        return tempInstance.kill();
      },
      update: function() {
        var _ref, _ref1;
        if ((this.x < (_ref = ig.input.mouse.x) && _ref < this.x + this.size) && (this.y < (_ref1 = ig.input.mouse.y) && _ref1 < this.y + this.size) && this.enabled) {
          this.hovered = true;
          if (ig.input.released("secondary_button")) {
            ig.game.buildQueue.add(this);
          }
          if (ig.input.released("primary_button") && this.queue.length > 0) {
            return ig.game.updatePlaceEntity(this.queue[0], this);
          }
        } else {
          return this.hovered = false;
        }
      },
      productionFinished: function(entity) {
        return this.queue.push(entity);
      },
      buildingPlaced: function() {
        this.queue.shift();
        if (this.queue.length > 0) {
          return ig.game.updatePlaceEntity(this.queue[0], this);
        } else {
          return ig.game.updatePlaceEntity();
        }
      },
      draw: function() {
        if (this.hovered) {
          this.buttonBack.drawTile(this.x, this.y, 1, this.size);
        } else {
          this.buttonBack.drawTile(this.x, this.y, 0, this.size);
        }
        this.image.drawTile(this.x, this.y, 0, this.size);
        if (!this.enabled) {
          this.buttonBack.drawTile(this.x, this.y, 1, this.size);
        }
        return ig.game.font.draw(this.queue.length.toString(), this.x, this.y - 6);
      }
    });
    BuildQueue = ig.Class.extend({
      queueBack: new ig.Image("media/queue_button.png"),
      init: function(x, y) {
        this.x = x;
        this.y = y;
        this.tileSize = 16;
        this.queue = [];
        this.costCompleted = 0;
        return this.hover = null;
      },
      add: function(buildButton) {
        return this.queue.push([buildButton, ig.game.spawnEntity(buildButton.buildingClass, -100, -100)]);
      },
      update: function() {
        var _ref, _ref1, _ref2, _ref3;
        this.hover = null;
        if (this.queue.length > 0) {
          this.costCompleted += ig.game.production / 60.0;
          if (this.costCompleted >= this.queue[0][1].getProductionCost()) {
            this.queue[0][0].productionFinished(this.queue[0][1]);
            this.queue.shift();
            this.costCompleted = 0;
          }
          if ((this.x < (_ref = ig.input.mouse.x) && _ref < this.x + this.tileSize * this.queue.length)) {
            if ((this.y < (_ref1 = ig.input.mouse.y) && _ref1 < this.y + this.tileSize)) {
              this.hover = Math.floor((ig.input.mouse.x - this.x) / 16);
            }
          }
        }
        if ((this.hover != null) && (ig.input.released("primary_button") || ig.input.released("secondary_button"))) {
          [].splice.apply(this.queue, [(_ref2 = this.hover), this.hover - _ref2 + 1].concat(_ref3 = [])), _ref3;
          if (this.hover === 0) {
            return this.costCompleted = 0;
          }
        }
      },
      getScaledPercentDone: function() {
        return Math.max(Math.floor(this.costCompleted * 16.0 / this.queue[0][1].getProductionCost()), 0.00001);
      },
      drawQueueItem: function(button, i) {
        this.queueBack.drawTile(this.x + i * 16, this.y, 0, this.tileSize);
        button.image.drawTile(this.x + i * 16, this.y, 0, this.tileSize);
        if (i === 0) {
          return this.queueBack.draw(this.x, this.y - 6, 32, 0, this.getScaledPercentDone(), 6);
        }
      },
      draw: function() {
        var i, queueItem, _i, _len, _ref;
        _ref = this.queue;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          queueItem = _ref[i];
          this.drawQueueItem(queueItem[0], i);
        }
        if (this.hover != null) {
          return this.queueBack.drawTile(this.x + this.hover * 16, this.y, 1, this.tileSize);
        }
      }
    });
    advRobotics = {
      cost: 1000,
      enabled: true,
      researched: false,
      name: "Advanced Robotics",
      desc: "Awesome robots work the mines more efficiently than humans!",
      bonuses: "Increases the efficiency of your mines.",
      quote: "Beep. Whiirrrrrrrrr.",
      onResearched: function() {
        return extremeRobotics.enabled = true;
      }
    };
    extremeRobotics = {
      cost: 2000,
      enabled: false,
      researched: false,
      name: "Extreme Environment Robotics",
      desc: "Remote control of robots under extreme conditions renders a whole new class          of exploratory and geology problems solvable.",
      bonus: "Further increases the efficiency of your mines. Enables construction of           Asthenosphere Boreholes.",
      quote: "Beep. <lava bubble>. Whirrr.",
      onResearched: function() {
        return ig.game.buildButtons[4].enabled = true;
      }
    };
    highEnergyPhysics = {
      cost: 1000,
      enabled: true,
      researched: false,
      name: "High Energy Physics",
      desc: "Development of the tools and methods to handle high energy matter states gives          you the tools for discovering what the universe is really made of.",
      bonus: "Enables construction of Supercolliders.",
      quote: "But, but, the chance of forming a black hole is like really really small!",
      onResearched: function() {
        ig.game.buildButtons[5].enabled = true;
        return quantumComputing.enabled = true;
      }
    };
    quantumComputing = {
      cost: 2000,
      enabled: false,
      researched: false,
      name: "Quantum Computing",
      desc: "Understanding more of the subatomic particles of the universe, the first          reliable quantum computers are built and go into service.",
      bonus: "Enables construction of Quantum-Optical Comptrollers.",
      quote: "Wednesday, we'll calculate all the digits of Pi; Thursday, we should work on           that overdue 30-billion-node neural net, and Friday, what the hell, let's           simulate the universe.",
      onResearched: function() {
        ig.game.buildButtons[6].enabled = true;
        return unifiedTheory.enabled = true;
      }
    };
    theoryOfEverything = {
      cost: 3000,
      enabled: false,
      researched: false,
      name: "Theory of Everything",
      desc: "Using data from High Energy Physics and analysis tools from Quantum Computing,          the first truly universal theory of physics is discovered.",
      bonus: "Enables construction of Dome Generators.",
      quote: "It makes so much sense! Igor, why didn't we think of this before?!",
      onResearched: function() {
        ig.game.buildButtons[7].enabled = true;
        return secretsOfTheUniverse.enabled = true;
      }
    };
    secretsOfTheUniverse = {
      cost: 5000,
      enabled: false,
      researched: false,
      name: "Secrets of the Universe",
      desc: "???",
      bonus: "???",
      quote: "And there they were, the mortals, always rushing to the end of their hurried           lives. I saw everything, and it was sad and beautiful.",
      onResearched: function() {
        ig.game.winning = true;
        return ig.game.winCondition = "secrets";
      }
    };
    MyGame = ig.Game.extend({
      font: new ig.Font('media/04b03.font.png'),
      leftPanelBg: new ig.Image("media/left_panel.png"),
      lowerPanelBg: new ig.Image("media/lower_panel.png"),
      pauseBlackout: new ig.Image("media/pause_blackout.png"),
      init: function() {
        ig.input.bind(ig.KEY.MOUSE1, 'primary_button');
        ig.input.bind(ig.KEY.MOUSE2, 'secondary_button');
        ig.input.bind(ig.KEY.SPACE, "pause");
        this.paused = false;
        this.spawnEntity(BackGround, 0, 0);
        this.updatePlaceEntity(null);
        this.buildButtons = [new BuildingButton(61, 224, Mine), new BuildingButton(77, 224, Generator), new BuildingButton(93, 224, Factory), new BuildingButton(113, 224, ResearchCenter), new BuildingButton(129, 224, Borehole, false), new BuildingButton(145, 224, Supercollider, false), new BuildingButton(161, 224, QuantomOptoComptroller, false), new BuildingButton(177, 224, DomeGenerator, false)];
        this.alerts = [
          {
            text: "Here's a sample alert!",
            time: 120
          }
        ];
        this.priorityAlert = null;
        this.buildButtons[0].productionFinished(ig.game.spawnEntity(Mine, -100, -100));
        this.buildButtons[0].productionFinished(ig.game.spawnEntity(Mine, -100, -100));
        this.buildButtons[1].productionFinished(ig.game.spawnEntity(Generator, -100, -100));
        this.buildButtons[1].productionFinished(ig.game.spawnEntity(Generator, -100, -100));
        this.buildButtons[2].productionFinished(ig.game.spawnEntity(Factory, -100, -100));
        this.buildQueue = new BuildQueue(200, 224);
        this.updateEconomyState();
        return this.researchGoal = {
          name: ""
        };
      },
      updatePlaceEntity: function(placeEntity, buttonToUpdate) {
        this.buttonToUpdate = buttonToUpdate;
        if (this.placeEntity != null) {
          if (!this.placeEntity.placed) {
            this.placeEntity.pos.x = -300;
          }
        }
        this.placeEntity = placeEntity;
        if ((placeEntity != null) && (placeEntity.currentAnim != null)) {
          return this.placeEntity.currentAnim.alpha = 0.5;
        }
      },
      updateEconomyState: function() {
        var entity, placedEntities, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _results;
        this.energyProduced = 0;
        this.energyConsumed = 0;
        this.mineralsProduced = 0;
        this.mineralsConsumed = 0;
        this.production = 0;
        this.research = 0;
        placedEntities = (function() {
          var _i, _len, _ref, _results;
          _ref = this.entities;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            entity = _ref[_i];
            if (entity.placed) {
              _results.push(entity);
            }
          }
          return _results;
        }).call(this);
        for (_i = 0, _len = placedEntities.length; _i < _len; _i++) {
          entity = placedEntities[_i];
          this.energyProduced += entity.getEnergyProduced();
        }
        for (_j = 0, _len1 = placedEntities.length; _j < _len1; _j++) {
          entity = placedEntities[_j];
          this.energyConsumed += entity.getEnergyConsumed();
        }
        for (_k = 0, _len2 = placedEntities.length; _k < _len2; _k++) {
          entity = placedEntities[_k];
          this.mineralsProduced += entity.getMineralsProduced();
        }
        for (_l = 0, _len3 = placedEntities.length; _l < _len3; _l++) {
          entity = placedEntities[_l];
          this.mineralsConsumed += entity.getMineralsConsumed();
        }
        for (_m = 0, _len4 = placedEntities.length; _m < _len4; _m++) {
          entity = placedEntities[_m];
          this.production += entity.getProductionProduced();
        }
        _results = [];
        for (_n = 0, _len5 = placedEntities.length; _n < _len5; _n++) {
          entity = placedEntities[_n];
          _results.push(this.research += entity.getResearch());
        }
        return _results;
      },
      update: function() {
        var button, placeX, placeY, _i, _len, _ref;
        if (!this.paused) {
          this.updateEconomyState();
          this.parent();
          _ref = this.buildButtons;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            button.update();
          }
          this.buildQueue.update();
          placeX = Math.floor(ig.input.mouse.x / 16) * 16;
          placeY = Math.floor(ig.input.mouse.y / 16) * 16;
          if (ig.input.released("primary_button") && this.legalPlacement(placeX, placeY)) {
            if ((this.placeEntity != null) && this.placeEntity.canPlace()) {
              this.placeEntity.place();
            }
            if (this.buttonToUpdate != null) {
              this.buttonToUpdate.buildingPlaced();
            }
          } else if (this.placeEntity) {
            this.placeEntity.pos.x = placeX;
            this.placeEntity.pos.y = placeY;
          }
          if (this.alerts.length > 0) {
            this.alerts[0].time -= 1;
            if (this.alerts[0].time <= 0) {
              this.alerts.shift();
            }
          }
        }
        if (ig.input.released("pause")) {
          return this.paused = !this.paused;
        }
      },
      legalPlacement: function(x, y) {
        if (x < 64) {
          return y < 176;
        } else {
          return y < 192;
        }
      },
      draw: function() {
        var button, _i, _len, _ref;
        this.parent();
        this.lowerPanelBg.draw(-32, 193);
        if (this.alerts.length > 0) {
          this.font.draw(this.alerts[0].text, 61, 195);
        }
        this.lowerPanelBg.draw(-16, 201);
        this.font.draw(sprintf("Research: %+.0d", this.research), 61, 203);
        this.font.draw("Goal: " + this.researchGoal.name, 140, 203);
        this.lowerPanelBg.draw(0, 209);
        this.font.draw("Build:", 61, 212);
        _ref = this.buildButtons;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          button = _ref[_i];
          button.draw();
        }
        this.font.draw("Queue:", 200, 212);
        this.buildQueue.draw();
        this.leftPanelBg.draw(0, 181);
        this.font.draw("Minerals:", 1, 185);
        this.font.draw(sprintf("%.0d-%.0d=%+.0d", this.mineralsProduced, this.mineralsConsumed, this.mineralsProduced - this.mineralsConsumed), 1, 193);
        this.font.draw("Energy:", 1, 205);
        this.font.draw(sprintf("%.0d-%.0d=%+.0d", this.energyProduced, this.energyConsumed, this.energyProduced - this.energyConsumed), 1, 213);
        this.font.draw("Production:", 1, 225);
        this.font.draw(sprintf("%+.0d", this.production), 1, 233);
        if (this.paused) {
          return this.pauseBlackout.draw(0, 0);
        }
      }
    });
    return ig.main('#canvas', MyGame, 60, 320, 240, 2);
  });

}).call(this);
